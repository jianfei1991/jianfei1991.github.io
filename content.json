[{"title":"Hello World","date":"2028-04-18T07:05:06.000Z","path":"2028/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"linux常用命令","date":"2018-09-16T17:10:02.000Z","path":"2018/09/17/linux常用命令/","text":"mkdir ls rm -rf wget grep cp mv ln cat vim pwd ln find chmod chown tar -zxvf 解压gzip grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug” ps aux 查看当前进程 top","tags":[]},{"title":"nginx","date":"2018-09-16T17:01:10.000Z","path":"2018/09/17/nginx/","text":"安装nginx官网 复制 稳定版本（stable version）链接 进入服务器 wget http://nginx.org/download/nginx-1.14.0.tar.gz 下载完成后 tar zxvf nginx*(tab补全) 进入nginx目录 执行 ./configure 会生成objs目录 执行make install 系统会把nginx 安装到 /usr/local/nginx 执行文件是/usr/local/nginx/sbin/nginx Nginx -t 测试配置文件是否有问题 nginx -s reload 重启nginx Ps -ef | grep nginx 查找进程中是否有启动的nginx lsof -i:80 查看占用80端口的进程 配置文件/conf/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;","tags":[]},{"title":"todo","date":"2018-09-05T16:02:30.000Z","path":"2018/09/06/todo/","text":"安装Sublime CMD+shift+P install PlainTasks 快捷键 快捷键 备注 作用 CMD+shif+p 输入tasks: New document 创建新文档 CMD+i 创建新的task ctrl+c 取消task CMD+d 完成 CMD+shift+a 归档 –tab 漂亮的分割线 CMD+shift+p 输入Tasks: Copy Statistics 在文本中粘贴即可显示你的任务完成度 生成统计 配置如果遇到不能显示的字符，可以在配置文件中修改，进度条可以在用户配置文件中加入： “bar_full”: “■”, // any char“bar_empty”: “☐”, // any char// if you want to avoid Unicode when copy stats — you can define replacements// e.g. to convert ■■■■■■☐☐☐☐ to [====== ]“replace_stats_chars”: [[“ ■”, “ [=”], [“■”, “=”], [“☐ “, “ ] “], [“☐”, “ “]]}任务的轻重缓急等设置c tab —— @critical，用于标注任务重要程序，表示极重要的h tab —— @high，用于标注任务重要程序l tab —— @low，用于标注任务重要程序s tab —— @started ，再按tab键就会插入当前时间，这样当你完成任务时可以知道耗时多少d tab —— @due() 设置任务期限，格式为@due(year-month-day hour:minute)，以下内容再输入tab即可扩充为这个格式。@due(+) —— 明天，同@due( +1) 和 @due( +1d)@due(+w) —— 一周，同@(due +1)。另外+3w就表示三周@due(+2:) —— 两小时@due(+:45) —— 45分钟@due(+2 12:) —— 两天十二小时@due(1) —— 下个月一号@due(5) —— 这个月或者下个月5号，是这个月还是下个月取决当前日期是否大于5@due(2-3) —— 今年或明年2月3号，取决于当前日期是否大于2月3号@due(25 23:) —— 这个月或下个月25号，23时，分钟等于当前的分钟@due(16.1.1 1:1) —— 等于@due(16-01-01 01:01)","tags":[]},{"title":"函数式编程","date":"2018-08-22T15:38:58.000Z","path":"2018/08/22/函数式编程/","text":"函数式编程思维 函数式编程常用核心概念 当下函数式编程最热的库 函数式编程的实际应用场景 函数式编程思维是一门复杂的数学思想 函数是”第一等公民” 只用”表达式”，不用”语句” 没有”副作用” 不修改状态 引用透明（函数运行只靠参数） 函数式编程常用核心概念•纯函数 •函数的柯里化 •函数组合 •Point Free •声明式与命令式代码 •核心概念 1.纯函数对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。 12345var xs = [1,2,3,4,5];// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的xs.slice(0,3);xs.slice(0,3);xs.splice(0,3);// Array.splice会对原array造成影响，所以不纯xs.splice(0,3); 2.函数的柯里化传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 12var min = 18; var checkage = age =&gt; age &gt; min; 这个函数并不纯，checkage 不仅取决于 age还有外部依赖的变量 min。 纯的 checkage 把关键数字 18 硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。 123var checkage = min =&gt; (age =&gt; age &gt; min);var checkage18 = checkage(18); // 先将18作为参数，去调用此函数，返回一个函数age =&gt; age &gt; 18;checkage18(20);// 第二步，上面返回的函数去处理剩下的参数，即 20 =&gt; 20 &gt; 18; return true; 123456789101112// 柯里化之前function add(x, y) &#123; return x + y;&#125;add(1, 2) // 3// 柯里化之后function addX(y) &#123; return function (x) &#123; return x + y; &#125;;&#125;addX(2)(1) // 3 事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。 3.函数组合为了解决函数嵌套过深，洋葱代码：addX(2)(1)、h(g(f(x)))，我们需要用到“函数组合”，我们一起来用柯里化来改他，让多个函数像拼积木一样。 12345const compose = (f, g) =&gt; (x =&gt; f(g(x)));var first = arr =&gt; arr[0];var reverse = arr =&gt; arr.reverse();var last = compose(first, reverse);last([1, 2, 3, 4, 5]); // 5 函数组合交换律，类似于乘法交换律： 4.Point Free把一些对象自带的方法转化成纯函数,不要命名转瞬即逝的中间变量。 1const f = str =&gt; str.toUpperCase().split(' '); 这个函数中，我们使用了 str 作为我们的中间变量，但这个中间变量除了让代码变得长了一点以外是毫无意义的。 1234var toUpperCase = word =&gt; word.toUpperCase();var split = x =&gt; (str =&gt; str.split(x));var f = compose(split(' '), toUpperCase);f(\"abcd efgh\"); 把一些对象自带的方法转化成纯函数，然后通过函数组合去调用，这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。是不是很方便！ 5.声明式与命令式代码在我们日常业务开发中，写的代码绝大多数都为命令式代码；我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。 1234567//命令式let CEOs = [];for (var i = 0; i &lt; companies.length; i++) &#123; CEOs.push(companies[i].CEO)&#125;//声明式let CEOs = companies.map(c =&gt; c.CEO); 函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于我们的心智来说是极大的负担。 6.核心概念高阶函数​ 把函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。 12345678//命令式var add = function (a, b) &#123; return a + b;&#125;;function math(func, array) &#123; return func(array[0], array[1]);&#125;math(add, [1, 2]); // 3 递归与尾递归指函数内部的最后一个动作是函数调用。 该调用的返回值， 直接返回给函数。 函数调用自身， 称为递归。1234567891011121314151617181920function quickSort(arr)&#123;//！！递归快排！！！ if(arr.length&lt;=1)&#123;return arr;&#125; //如果数组&lt;=1,则直接返回 var pivotIndex=Math.floor(arr.length/2); var pivot=arr.splice(pivotIndex,1)[0]; //找基准，并把基准从原数组删除 var left=[]; //定义左右数组 var right=[]; //比基准小的放在left，比基准大的放在right for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;=pivot)&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125; 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。","tags":[]},{"title":"ASCII、Unicode和UTF-8编码的区别","date":"2018-08-17T08:07:31.000Z","path":"2018/08/17/ASCII、Unicode和UTF-8编码的区别/","text":"编码 大小 支持语言 ASCII 1个字节 英文 Unicode 2个字节（生僻字4个） 所有语言 UTF-8 1-6个字节，英文字母1个字节，汉字3个字节，生僻字4-6个字节 所有语言 具体解释：最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。","tags":[]},{"title":"HTTP Cache-Control","date":"2018-08-09T07:49:49.000Z","path":"2018/08/09/HTTP-Cache-Control/","text":"Cache-Control指定了请求和响应遵循的缓存机制。好的缓存机制可以减少对网络带宽的占用，可以提高访问速度，提高用户的体验，还可以减轻服务器的负担。 https://www.cnblogs.com/chinajava/p/5705169.html no-cache和no-store的区别网上有好多关于no-cache和no-store的区别，但是长篇大论，感觉也没有怎么讲清楚。 最近看了《图解HTTP》这本书，书上讲到了这两者的区别： no-cache从字面意义上很容易误解为不缓存，但是no-cache代表不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源，更确切的说，no-cache应该是 1do-not-serve-from-cache-without-revalidation 而no-store才是真正的不进行缓存。 使用no-cache的目的就是为了防止从缓存中获取过期的资源。 Cache-Control主要有以下几种类型： (1) 请求Request： [1] no-cache —- 不要读取缓存中的文件，要求向WEB服务器重新请求 [2] no-store —- 请求和响应都禁止被缓存[2] max-age： —- 表示当访问此网页后的max-age秒内再次访问不会去服务器请求，其功能与Expires类似，只是Expires是根据某个特定日期值做比较。一但缓存者自身的时间不准确.则结果可能就是错误的，而max-age,显然无此问题.。Max-age的优先级也是高于Expires的。[3] max-stale —- 允许读取过期时间必须小于max-stale 值的缓存对象。[4] min-fresh —- 接受其max-age生命期大于其当前时间 跟 min-fresh 值之和的缓存对象 [5] only-if-cached —- 告知缓存者,我希望内容来自缓存，我并不关心被缓存响应,是否是新鲜的. [6] no-transform —- 告知代理,不要更改媒体类型,比如jpg,被你改成png. (2) 响应Response： [1] public —- 数据内容皆被储存起来，就连有密码保护的网页也储存，安全性很低[2] private —- 数据内容只能被储存到私有的cache，仅对某个用户有效，不能共享[3] no-cache —- 可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端 [4] no-store —- 请求和响应都禁止被缓存 [4] max-age： —– 本响应包含的对象的过期时间[5] Must-revalidate —- 如果缓存过期了，会再次和原来的服务器确定是否为最新数据，而不是和中间的proxy [6] max-stale —- 允许读取过期时间必须小于max-stale 值的缓存对象。 [7] proxy-revalidate —- 与Must-revalidate类似，区别在于：proxy-revalidate要排除掉用户代理的缓存的。即其规则并不应用于用户代理的本地缓存上。 [8] s-maxage —- 与max-age的唯一区别是,s-maxage仅仅应用于共享缓存.而不应用于用户代理的本地缓存等针对单用户的缓存. 另外,s-maxage的优先级要高于max-age. [9] no-transform —- 告知代理,不要更改媒体类型,比如jpg,被你改成png.","tags":[]},{"title":"Sublime 入门","date":"2018-07-18T13:20:52.000Z","path":"2018/07/18/Sublime-入门/","text":"Theme: https://github.com/equinusocio/material-theme– CMD+, “color_scheme”: “Packages/Material Theme/schemes/Material-Theme.tmTheme”, &quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, –","tags":[]},{"title":"git相关操作","date":"2018-04-18T07:05:06.000Z","path":"2018/04/18/git相关操作/","text":"git 对比两个分支差异 git 对比两个分支差异 git 小游戏 githug git学习笔记 git tag相关 更改git log展示","tags":[]},{"title":"vim常用快捷键","date":"2018-04-10T07:43:08.000Z","path":"2018/04/10/vim常用快捷键/","text":"一、移动光标h,j,k,l 上，下，左，右ctrl-e 移动页面ctrl-f 上翻一页ctrl-b 下翻一页ctrl-u 上翻半页ctrl-d 下翻半页w 跳到下一个字首，按标点或单词分割W 跳到下一个字首，长跳，如end-of-line被认为是一个字e 跳到下一个字尾E 跳到下一个字尾，长跳b 跳到上一个字B 跳到上一个字，长跳0 跳至行首，不管有无缩进，就是跳到第0个字符^ 跳至行首的第一个字符$ 跳至行尾gg 跳至文首G 调至文尾5gg/5G 调至第5行gd 跳至当前光标所在的变量的声明处fx 在当前行中找x字符，找到了就跳转至; 重复上一个f命令，而不用重复的输入fx* 查找光标所在处的单词，向下查找# 查找光标所在处的单词，向上查找 二、删除复制dd 删除光标所在行dw 删除一个字(word)d/D删除到行末x删除当前字符X删除前一个字符yy复制一行yw复制一个字y/Y 复制到行末p 粘贴粘贴板的内容到当前行的下面P 粘贴粘贴板的内容到当前行的上面 三、插入模式i 从当前光标处进入插入模式I 进入插入模式，并置光标于行首a 追加模式，置光标于当前光标之后A 追加模式，置光标于行末o 在当前行之下新加一行，并进入插入模式O 在当前行之上新加一行，并进入插入模式Esc 退出插入模式 四、编辑J 将下一行和当前行连接为一行cc 删除当前行并进入编辑模式cw 删除当前字，并进入编辑模式c$ 擦除从当前位置至行末的内容，并进入编辑模式s 删除当前字符并进入编辑模式S 删除光标所在行并进入编辑模式xp 交换当前字符和下一个字符u 撤销ctrl+r 重做~ 切换大小写，当前字符>&gt; 将当前行右移一个单位&lt;&lt; 将当前行左移一个单位(一个tab符)== 自动缩进当前行 五、查找替换/pattern 向后搜索字符串pattern?pattern 向前搜索字符串pattern“\\c” 忽略大小写“\\C” 大小写敏感 n 下一个匹配(如果是/搜索，则是向下的下一个，?搜索则是向上的下一个)N 上一个匹配(同上):%s/old/new/g 搜索整个文件，将所有的old替换为new:%s/old/new/gc 搜索整个文件，将所有的old替换为new，每次都要你确认是否替换 六、退出编辑器:w 将缓冲区写入文件，即保存修改:wq 保存修改并退出:x 保存修改并退出:q 退出，如果对缓冲区进行过修改，则会提示:q! 强制退出，放弃修改 七、多文件编辑vim file1.. 同时打开多个文件:args 显示当前编辑文件:next 切换到下个文件:prev 切换到前个文件:next！ 不保存当前编辑文件并切换到下个文件:prev！ 不保存当前编辑文件并切换到上个文件:wnext 保存当前编辑文件并切换到下个文件:wprev 保存当前编辑文件并切换到上个文件:first 定位首文件:last 定位尾文件ctrl+^ 快速在最近打开的两个文件间切换:split[sp] 把当前文件水平分割:split file 把当前窗口水平分割, file:vsplit[vsp] file 把当前窗口垂直分割, file:new file 同split file:close 关闭当前窗口:only 只显示当前窗口, 关闭所有其他的窗口:all 打开所有的窗口:vertical all 打开所有的窗口, 垂直打开:qall 对所有窗口执行：q操作:qall! 对所有窗口执行：q!操作:wall 对所有窗口执行：w操作:wqall 对所有窗口执行：wq操作ctrl-w h 跳转到左边的窗口ctrl-w j 跳转到下面的窗口ctrl-w k 跳转到上面的窗口ctrl-w l 跳转到右边的窗口ctrl-w t 跳转到最顶上的窗口ctrl-w b 跳转到最底下的窗口 八、多标签编辑:tabedit file 在新标签中打开文件file:tab split file 在新标签中打开文件file:tabp 切换到前一个标签:tabn 切换到后一个标签:tabc 关闭当前标签:tabo 关闭其他标签gt 到下一个tabgT 到上一个tab0gt 跳到第一个tab5gt 跳到第五个tab 九、执行shell命令1、在命令模式下输入”:sh”，可以运行相当于在字符模式下，到输入结束想回到VIM编辑器中用exit，ctrl+D返回VIM编辑器2、可以”!command”，运行结束后自动回到VIM编辑器中3、用“Ctrl+Z“回到shell，用fg返回编辑4、:!make -&gt; 直接在当前目录下运行make指令 十、VIM启动项-o[n] 以水平分屏的方式打开多个文件-O[n] 以垂直分屏的方式打开多个文件 十一、自动排版在粘贴了一些代码之后，vim变得比较乱，只要执行gg=G就能搞定 十二、如何在vim中编译程序在vim中可以完成make,而且可以将编译的结果也显示在vim里，先执行 :copen 命令，将结果输出的窗口打开，然后执行 :make编译后的结果就显示在了copen打开的小窗口里了，而且用鼠标双击错误信息，就会跳转到发生错误的行。 十三、buffer操作1、buffer状态- （非活动的缓冲区）a （当前被激活缓冲区）h （隐藏的缓冲区）% （当前的缓冲区）# （交换缓冲区）= （只读缓冲区）+ （已经更改的缓冲区） 十四、 VIM 操作目录1.打开目录vim .vim a-path/ 2.以下操作在操作目录时生效p,P,t,u,U,x,v,o,r,s c 使当前打开的目录成为当前目录d 创建目录% 创建文件D 删除文件/目录- 转到上层目录gb 转到上一个 bookmarked directoryi 改变目录文件列表方式^l 刷新当前打开的目录 mf - 标记文件mu - unmark all marked filesmz - Compress/decompress marked filesgh 显示/不显示隐藏文件( dot-files)^h 编辑隐藏文件列表a 转换显示模式, all - hide - unhideqf diplay infomation about fileqb list the bookmarked directories and directory traversal historygi Display information on file mbmcmd - 将标记的文件(mf标记文件)使用 diff 模式me - 编辑标记的文件,只显示一个，其余放入 buffer 中mhmm - move marked files to marked-file target directorymc - copympmrmt vim 中复制,移动文件1, mt - 移动到的目录2, mf - 标记要移动的文件3, mc - 移动/复制 R 移动文件 打开当前编辑文件的目录:Explore:Hexplore:Nexplore:Pexplore:Sexplore:Texplore:Vexplore","tags":[]},{"title":"使用iTerm2快捷连接SSH","date":"2018-04-10T07:36:31.000Z","path":"2018/04/10/使用iTerm2快捷连接SSH/","text":"https://blog.csdn.net/fangxiaoji/article/details/50710220https://blog.csdn.net/ljp812184246/article/details/52585650注意事项 chmod a+x filename 通过 ./filename 执行","tags":[]},{"title":"vue中给svg组件的dom元素绑定点击事件","date":"2018-01-12T18:26:46.000Z","path":"2018/01/13/vue中给svg组件的dom元素绑定点击事件/","text":"问题描述:在vue中 给svg组件绑定dom元素，因为元素太多，用的jquery或者js原生绑定事件测试过程中，复用svg组件分别为 A、B如果用dom元素绑定点击事件，触发A或者B中任意一个点击事件，会同时触发A和B两个相同元素绑定的点击事件 暂无解决方案！！！难道要给众多的g标签分别添加绑定事件？ g标签内很多重复的东西，难道要把众多的g标签用v-for循环出来？ https://stackoverflow.com/questions/25886802/svg-path-convert-into-json var d = “M 93.00,444.00\\ C 93.00,444.00 114.00,506.00 114.00,506.00\\ 102.30,512.28 100.00,518.71 100.00,531.00\\ 100.00,531.00 86.00,534.00 86.00,534.00\\ 86.00,534.00 68.95,485.00 68.95,485.00\\ 68.95,485.00 58.00,452.00 58.00,452.00\\ 58.00,452.00 93.00,444.00 93.00,444.00 Z\\ M 75.00,458.00\\ C 75.00,458.00 79.00,458.00 79.00,458.00\\ 78.99,466.29 79.26,463.93 76.00,471.00\\ 76.00,471.00 86.00,471.00 86.00,471.00\\ 82.12,462.60 83.00,464.37 83.00,455.00\\ 83.00,455.00 75.00,458.00 75.00,458.00 Z” d = d.replace(/\\s{2,}/g, ‘ ‘); // Remove multiple spacesd = d.replace(/([a-zA-Z])\\s[0-9]/g, ‘$1,’); // Add letters to coords groupd = d.split(“ “); // Split on space var coords = []; for (var i = 0; i &lt; d.length; i++) { var coordString = d[i]; var coordArray = coordString.split(“,”); var coord = { x: coordArray[coordArray.length - 2], y: coordArray[coordArray.length - 1] }; if (coordArray.length &gt; 2) { coord.path = coordArray[0]; } coords.push(coord); } console.log(coords);","tags":[]},{"title":"面试题","date":"2017-07-18T09:39:37.000Z","path":"2017/07/18/面试题/","text":"美团 2017年07月20日css3（动画、flex)标签上下绝对剧中的几种方法css盒模型 box-sizingget post区别 1、公认意义上、get用来获取信息，post用来增加或者修改信息get请求数据 把参数放在http的协议头里面用问号拼接，后台接收到的是字符串post请求，会把参数放在http请求的包里，后台接收到的是form表单不同的浏览器对get请求的URL的长度有限制、post没有post更安全，因为get请求的参数可能会被浏览器缓存 标题超过宽度用css省略文字js两种继承方式原型链实例的__proto__指向构造函数的prototype,构造函数的prototype的__proto__指向上一级构造函数的prototype,一直到Object.prototype.__ptoto__==null就到头了，形成一条原型链 闭包 解决变量作用域的方案 onscroll 节流jsonp相对于ajax的缺点算法：快速排序 js异步执行顺序 css预编译 angular 数据绑定方式和原理，angular脏查询的原理 CSS绝对剧中transformanimationCSS3新特性新增的css3的选择器transformtransitionanimation:ani ease 1s; E:nth-last-child(n)E:nth-of-type(n)E:nth-last-of-type(n)E:last-childE:first-of-typeE:only-childE:only-of-typeE:emptyE:checkedE:enabledE:disabledE::selectionE:not(s)E::not(.s)body: nth-child(even), nth-child(odd)/：此处他们分别代表了表格（tbody）下面的偶数行和奇数行（tr）/等等…… ## 一面： 浏览器为什么不实现文件操作从键盘输入URL到网页呈现发生了什么（web服务器、DNS、驱动、协议、CDN、代理、渲染引擎、DOMTree+CSSRule、JS引擎）事件模型CSS3新特性、CSS绝对居中TCP/IP一定要三次握手吗对除get、post其他请求类型的了解前端缓存跨域xss、csrf攻击及防范基本数据类型Promise原理、实现异步的方法webpack类似的构建工具为什么前端模块化、工程化快速排序","tags":[]},{"title":"关于跨域","date":"2017-05-24T10:17:28.000Z","path":"2017/05/24/关于跨域/","text":"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552209&amp;idx=1&amp;sn=23eec5e98c4c9bed2417e78bfc57e320 http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html 十、阅读材料 1. Introduction to XMLHttpRequest Level 2： 新功能的综合介绍。 2. New Tricks in XMLHttpRequest 2：一些用法的介绍。 3. Using XMLHttpRequest：一些高级用法，主要针对Firefox浏览器。 4. HTTP Access Control：CORS综述。 5. DOM access control using cross-origin resource sharing：CORS的9种HTTP头信息 6. Server-Side Access Control：服务器端CORS设置。 7. Enable CORS：服务端CORS设置。 报错XMLHttpRequest cannot load https://testapi.shouqiev.com/activity/ImageFromGLByJsonp.json. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘https://mail.qq.com&#39; is therefore not allowed access. 测试http://www.qq.com/ 访问 http://testapi.shouqiev.com/activity/ImageFromGLByJsonp.json 跑通 无报错http://www.qq.com/ 访问 https://testapi.shouqiev.com/activity/ImageFromGLByJsonp.json 跑通 报错 返回值不能用https 访问 https (二级域名跨域) 跑通报错https 访问 https (二级域名跨域) 跑通报错 阅读材料-4 CORS综述Introduction 介绍Same-origin policies are a central security concept of modern browsers. In a web context, they prevent a script hosted at one origin — meaning the same protocol, domain name, and port — from reading from or writing to the DOM of another. 相同的原产地政策是现代浏览器的核心安全理念。在Web上下文中，它们防止从一个来源托管的脚本，意思是相同的协议、域名和端口。 This restriction is sensible and useful most of the time. Without a same-origin policy, a script hosted on http://foo.example could hijack cookie data or sensitive document information from http://bar.example and redirect it to http://evilsite.example. 这种限制是明智的和有用的大部分时间。没有同源策略，一个托管在http://foo.example脚本可以劫持cookie数据或从http://bar.example敏感文件信息并将其重定向到http://evilsite.example。 Sometimes, however, a same-origin policy can be burdensome. Making requests across subdomains, for example, is prohibited by a same-origin policy. You also can’t use XMLHttpRequest to pull in JSON data from a third-party API. To make matters worse, workarounds such as JSONP or document.domain can leave us vulnerable to XSS attacks. 然而，有时，相同的原产地政策可能是累赘。例如，在同一个原产地政策禁止跨子域的请求。你也不能使用XMLHttpRequest拉从一个第三方API的JSON数据。更糟糕的是，解决方法如json或document.domain可以让我们容易受到XSS攻击。 What we need, then, is a mechanism for requesting data across origins, but with the ability to deny requests that don’t come from the right source. This is the problem that Cross-Origin Resource Sharing (or CORS) solves. 然后，我们需要的是一个机制，要求跨来源的数据，但有能力拒绝的请求，不来自正确的来源。这是跨域资源共享问题的解决（或CORS）。 Cross-Origin Resource Sharing is new in Opera 12. Support is also available in Chrome, Safari, Firefox, and the forthcoming Internet Explorer 10. 跨起源资源共享歌剧12新。支持也可在Chrome，Safari，Firefox，以及即将到来的Internet Explorer 10。","tags":[]},{"title":"多SSH key的管理","date":"2017-05-18T09:48:21.000Z","path":"2017/05/18/多SSH-key的管理/","text":"| https://www.zybuluo.com/yangfch3/note/172120 ssh-keygen命令ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。-b：指定密钥长度；-e：读取openssh的私钥或者公钥文件；-C：添加注释；-f：指定用来保存密钥的文件名；-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；-l：显示公钥文件的指纹数据；-N：提供一个新密语；-P：提供（旧）密语；-q：静默模式；-t：指定要创建的密钥类型。","tags":[]},{"title":"mysql","date":"2017-04-15T04:25:46.000Z","path":"2017/04/15/mysql/","text":"使用MySQL数据库登录 MySQL运行时 可以通过命令行 mysql -h 主机名 -u 用户名 -p -h 制定要登录的主机名，登录当前及其该参数可以省略 创建一个数据库 create database 数据库名[其它选项就] 例如：create database samp_db character set gbk; (为了便于在命令提示符下显示中文character set gbk 将数据库字符编码指定为gbk) (创建成功时会得到 Query OK, 1 row affected(0.02 sec) 的响应)","tags":[]},{"title":"cookie","date":"2017-04-15T02:55:13.000Z","path":"2017/04/15/cookie/","text":"setCookie方法在localhost域名下不能存，在127.0.0.1下确可以存取123456789something that wasn&apos;t made clear to me here and totally confused me for a while was that domainnames must contain at least two dots (.),hence &apos;localhost&apos; is invalid and the browser will refuse to set the cookie!instead for localhost you should use false.to make your code work on both localhost and a proper domain, you can do this: 解决方案一： localhost指向127.0.0.1解决方案二： 改hosts三：php解决方案（网上搜的，看不明白php还。。。。）1234&lt;?php $domain = ($_SERVER[&apos;HTTP_HOST&apos;] != &apos;localhost&apos;) ? $_SERVER[&apos;HTTP_HOST&apos;] : false; setcookie(&apos;cookiename&apos;, &apos;data&apos;, time()+60*60*24*365, &apos;/&apos;, $domain, false); ?&gt;","tags":[]},{"title":"package.json","date":"2017-03-18T07:20:56.000Z","path":"2017/03/18/package-json/","text":"–save-dev &amp;&amp; –savepackage.json 中有dependencies和devDependenciesdependencies是用在开发完上线模式的，devDependencies是用在开发模式 依赖的版本控制 有的时候看到package.json中安装的模块版本号前面有一个波浪线。例如: ~1.2.3 这里表示安装1.2.x以上版本。但是不安装1.3以上。","tags":[]},{"title":"transition的坑","date":"2017-03-09T10:58:36.000Z","path":"2017/03/09/transition的坑/","text":"","tags":[]},{"title":"window onload","date":"2017-03-09T05:24:32.000Z","path":"2017/03/09/window-onload/","text":"window.onload &amp;&amp;DOMContentLoaded一般情况下，DOMContentLoaded事件要在window.onload之前执行，当DOM树构建完成的时候就会执行DOMContentLoaded事件，而window.onload是在页面载入完成的时候，才执行，这其中包括图片等元素。大多数时候我们只是想在DOM树构建完成后，绑定事件到元素，我们并不需要图片元素，加上有时候加载外域图片的速度非常缓慢。 随便照了几张大图简单测试了一下在几种方法第一行执行debugger window.onload 在图片资源加载完会后才出debugger DomContentLoaded、$(function(){})和$(document).ready(function(){})一样图片没有没有加载完就会出debugger","tags":[]},{"title":"rem入门","date":"2017-03-05T09:22:27.000Z","path":"2017/03/05/rem入门/","text":"为什么要用rem? 定宽布局在部分ios应用内不能正确显示。 rem是什么？ rem（font size of the root element）是指相对于根元素的字体大小的单位。 简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区别：它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 前端页面布局方式 响应式布局 从web page到web app直接一步到位，可以节约成本，不用再专门为自己的网站做一个web app的版本。 工作大，维护性难 流式布局 通过百分比来定一款杜，但是高度大都是用过px来固定 在大屏幕手机下显示效果会变成有些元素宽度呗拉得很长，但是高度还是和原来一样，导致显示不协调 对设计师有很大程度的限制 定宽布局 把宽度设置成320、640、750，超出的部分留白，这样前端可以照着设计稿直接写对应设计稿尺寸的px单位，工作效率高 早起的320在大屏幕手机下两边会有空白，并且操作按钮过小。 后来的640、750在能满足主流手机的全屏显示，但是在部分ios应用内有兼容问题 设置viewport进行缩放 天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。 使用过程中反应缩放会导致有些页面元素会糊的情况。 ’&lt;\\meta name=”viewport” content=”width=320,maximum-scale=1.3,user-scalable=no”&gt;‘ rem布局rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小 本文借鉴自： http://www.duanliang920.com/learn/web/html5/316.html","tags":[]},{"title":"record problem","date":"2017-01-13T09:22:30.000Z","path":"2017/01/13/record-problem/","text":"iphone webview 调试一切调通后 safari里面点击对应需要调试的页面 手机页面顶部显示“此网页出现问题，已重新载入”并重新加载，safari出现inspector后自动关闭 短期解决方案：安卓+weinre weinre1、安装2、执行weinre –boundHost -all-3、打开localhost:8080 找到页面中的 Target Script4、把Target Script 粘贴到需要调试的html中（注：如果是localhost需要换成本机的IP）开始调试https://blog.csdn.net/wuyajun1124/article/details/41622987","tags":[]},{"title":"react入门","date":"2017-01-12T08:59:09.000Z","path":"2017/01/12/react入门/","text":"","tags":[]},{"title":"解决UC浏览器、微信浏览器试用display:flex的兼容问题","date":"2017-01-06T08:02:57.000Z","path":"2017/01/06/解决UC浏览器、微信浏览器试用display-flex的兼容问题/","text":"http://blog.csdn.net/fanhu6816/article/details/52047018","tags":[]},{"title":"markdown入门","date":"2017-01-03T08:44:28.000Z","path":"2017/01/03/markdown入门/","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 “\\“ 代表强制换行或者“两个空格加回车” 标题11111 标题2222222 一级标题二级标题三级标题 1 2 3 1 2 3 1 2 3 列出所有元素： 无序列表元素 A 元素 A 的有序子列表 前面加四个空格 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 列表里引用： 前面空一行仍然需要在 &gt; 前面加四个空格 这里是引用 # MD中与无关内容间需要空一行 这里是引用中的引用 插入链接链接http://cdn.sspai.com/attachment/thumbnail/2014/04/15/f96c892fc63933ab186235f7c910753b10f77_mw_800_wm_1_wmp_3.jpg高级链接技巧 123456这个链接用 1 作为网址变量 [Google][1].这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 用两个*或者包含一段文本就是粗体的语法用一个*包含一段文本就是斜体的语法。 123$(document).ready(function () &#123; alert('hello world');&#125;); 转义字符12345678910111213Markdown中的转义字符为\\，转义的有：\\\\ 反斜杠\\` 反引号\\* 星号\\_ 下划线\\&#123;\\&#125; 大括号\\[\\] 中括号\\(\\) 小括号\\# 井号\\+ 加号\\- 减号\\. 英文句号\\! 感叹号 || Year || Temperature (low) || Temperature (high) |||| 1900 || -10 || 25 |||| 1910 || -15 || 30 |||| 1920 || -10 || 32 || Foo Foo2","tags":[]},{"title":"hexo介绍","date":"2017-01-03T08:43:19.000Z","path":"2017/01/03/hexo介绍/","text":"https://www.kancloud.cn/wizardforcel/hexo-doc/101374 需要安装Node.js、Git hexo init //进行初始化会自动生成下面这样的目录结构 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml配置文件，可以配置title、author、日期格式、deplpy–关联github的配置信息 scaffolds模板文件夹，新建文章的时候，Hexo会根据scaffold来建立文件 source资源文件夹。 除了_post 文件夹之外，开头命名为_的文件或文件夹和隐藏的文件将会被忽略。Markdown和html文件会被解析并放到public文件夹，而其他文件会被拷贝过去 themes主题文件夹。Hexo会根据主题来生成静态页面 huno 首页效果 看着还不错 yilia 综合效果不错 头像需要在yilia文件夹下的_config.yml里面设置avator参数 开始写文章$ hexo new “文章名”——通过这个命令来创建一篇新文章","tags":[]}]